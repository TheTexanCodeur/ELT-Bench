
import os, json
from string import Template
from typing import List

# Load your API key from environment
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
ANTHROPIC_API_KEY = os.getenv("ANTHROPIC_API_KEY")
taxonomy = json.load(open(os.path.join(os.path.dirname(__file__), "error_taxonomy.json")))


def alt_schema_linking_agent_prompt(question: str, table_schema: str, schema_agent_output="") -> str:
    return Template(
        """
You are a Schema Linking Agent in an NL2SQL framework.Return the relevant schema links for generating SQL query for the question.\n"

Given:
- A natural language question
- Database schemas with columns, primary keys (PK), and foreign keys (FK)

Cross-check your schema for:
- Missing or incorrect FK-PK relationships and add them
- Incomplete column selections (especially join keys)
- Table alias mismatches
- Linkage errors that would lead to incorrect joins or groupBy clauses

Question: $question

Table Schema:
$table_schema

Return the schema links in given format:

Table: primary_key_col, foreign_key_col, col1, col2, ... all other columns in Table

ONLY list relevant tables and columns and Foreign Keys in given format and no other extra characters.
"""
    ).substitute(
        question=question,
        table_schema=table_schema)



# 2. Subproblem Agent prompt
def subproblem_agent_prompt(question: str, schema_info: str) -> str:
    return Template(
        """
You are a Subproblem Agent in an NL2SQL framework. Your task is to decompose a natural language question into SQL subproblems.

You will be provided:
- A natural language question
- A textual schema summary that lists relevant tables and columns (generated by a Schema Agent)

Use this information to infer which SQL clauses are likely needed (e.g., WHERE, GROUPBY, JOIN, DISTINCT, ORDER BY, HAVING, EXCEPT, LIMIT, UNION).

Question:
$question

Schema:
$schema

Output a JSON object containing a list of subproblems:
{
  "subproblems": [
    { "clause": "SELECT", "expression": "..." },
    { "clause": "JOIN", "expression": "..." },
    ...
  ]
}

Only output valid JSON â€” no markdown, no extra commentary.

"""
    ).substitute(question=question.strip(), schema=schema_info.strip())

# 3. Query Plan Agent prompt
def query_plan_agent_prompt(question: str, schema_info: str, subproblem_json="", subprob_plan="", critic_issues= None) -> str:
    base_prompt = Template(
        """
You are a Query Plan Agent in an NL2SQL Framework. Using the question, schema info, and subproblems, generate a step-by-step SQL query plan. Use Chain of Thought to think through the process.

Question: $question
Schema Info:
$schema_info
Subproblems:
$subproblem_json

$critic_feedback

$subprob_plan

Return plan steps with specific table, column names like:
1. FROM tableA
2. JOIN tableB ON tableA.colX = tableB.colY
3. JOIN tableC ON tableB.colZ = tableC.colW

Return only the plan (no SQL or extra text).
"""
    )
    if critic_issues:
        feedback = "\nPREVIOUS ERRORS TO AVOID:\n"
        feedback += "\n".join([f"- {issue}" for issue in critic_issues])
        feedback += "\n Generate a query plan that FIXES all listed errors.\n"
    else:
        feedback = ""

    return base_prompt.substitute(question=question, schema_info=schema_info, subproblem_json=subproblem_json, critic_feedback=feedback, subprob_plan=subprob_plan)

# 4. SQL Generating Agent prompt
def sql_agent_prompt(question, plan: str, schema=None, subprob_sql="", critic_issues : list = None) -> str:
    base_prompt = Template(
        """
You are a world-class SQL writer AI in an NL2SQL multiagent framework. Your task is to write a single, syntactically correct SQL query that perfectly implements the provided query plan.
Pay close attention to the table and column names in the schema.

$question

Plan:
$plan

$schema

$subprob_sql

$critic_feedback

Write ONLY the final valid SQL query. Do NOT include commentary or unnecessary characters in the query.
"""
    )
    if critic_issues:
        feedback = "\nENSURE THAT YOU ADDRESS THESE ERRORS:\n" + "\n".join(f"- {e}" for e in critic_issues)
    else:
        feedback = ""
    if schema:
        schema_info = "\n Relevant Table Schema: \n" + schema
    else:
        schema_info = ""
    return base_prompt.substitute(plan=plan, schema=schema_info, critic_feedback=feedback, subprob_sql=subprob_sql, question=question)

def correction_sql_agent_prompt(question: str, schema, correction_plan, wrong_sql) -> str:
    return Template("""
You are an expert SQL debugger AI in NL2SQL multiagent framework. Your previous attempt to write a query failed.
Your new task is to analyze the feedback and your incorrect query, then generate a new, corrected query after reading the question and analyzing the relevant schema.

Question:
$question 

Incorrect SQL:
$wrong_sql

Correction query plan- You MUST follow these steps to fix the query:
$correction_plan

$schema

Write ONLY the final valid SQL query. Do NOT include commentary or unnecessary characters in the query.
"""
    ).substitute(question=question, wrong_sql=wrong_sql, schema=schema, correction_plan=correction_plan)

def correction_plan_agent_prompt(question: str, wrong_sql: str, schema, database_error=None) -> str:
    base = Template(
    """
You are a Senior SQL Debugger in an NL2SQL multiagent framework. Your sole task is to analyze a failed SQL query to create a clear, step-by-step correction plan using Chain of Thought. Do NOT write the corrected SQL yourself.

You are an expert in a comprehensive error taxonomy, including categories like:

- `schema.mismatch`: The query references tables, columns, or functions that do not exist in the schema, or uses them ambiguously.
- `join.logic_error`: Tables are connected incorrectly. This includes missing JOIN conditions, wrong foreign keys, using the wrong columns to join, or including unnecessary tables.
- `filter.condition_error`: The WHERE or HAVING clauses are incorrect. This can mean filtering on the wrong column, using the wrong operator or value, or confusing the use of HAVING with WHERE.
- `aggregation.grouping_error`: Errors related to aggregate functions like COUNT or SUM. This typically involves a missing or incomplete GROUP BY clause, or incorrect use of HAVING.
- `select.output_error`: The final columns being selected are wrong. The query might be returning extra columns, missing required columns, or presenting them in the wrong order.
- `syntax.structural_error`: The query has fundamental syntax errors or is missing critical clauses required by the question, such as ORDER BY, LIMIT, or set operators like UNION and INTERSECT.
- `intent.semantic_error`: The query is syntactically valid but fails to capture the user's true intent. This includes using incorrect hardcoded values or failing to implement a required subquery or leaving out a logical solution.

**Your Reasoning Process:*:
1.  **Pinpoint the Mismatch:** Read the question and compare it to the `Failed SQL Query` and the `Pruned Schema` to find the exact source of the error.
2.  **Find error type:** Read error taxonomy categories given above and try to identify the error in this query. Analyze the joins, aggregation, distinction, limits and except clauses applied carefully.
3.  **Formulate a Hypothesis:** State the root cause of the error in a single sentence. Look out for simple errors in column names like 'name' instead of 'song_name' etc.
4.  **Create the Plan:** Write a concise, step-by-step natural language plan that a junior SQL developer can follow to fix the query.

**Input for Analysis:**

**1. Original Question:**
"$question"

**2. Relevant Schema:**
$schema

**3. Failed SQL Query:**
$wrong_sql

$database_error

There IS an error in the query. DO NOT return "no error, query seems fine". Provide a clear, step-by-step explanation of why the query is wrong and exactly how to fix it. Return ONLY the query error and correction plan, don't generate SQL.
""")
    if database_error:
        prompt = "**4. Query Execution Error:** \n" + database_error
    return base.substitute(question=question.strip(), wrong_sql=wrong_sql.strip(), schema=schema, database_error=database_error)
